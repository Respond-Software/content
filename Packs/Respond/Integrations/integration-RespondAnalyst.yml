category: Analytics & SIEM
commonfields:
  id: Respond_Analyst
  version: -1
configuration:
- defaultvalue: ""
  display: base url
  name: base_url
  required: true
  type: 0
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Password
  name: password
  required: true
  type: 4
- defaultvalue: ""
  display: Username
  name: username
  required: true
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
description: Respond Software Description
display: Respond Analyst (Developer Contribution)
name: Respond_Analyst
script:
  commands:
  - arguments:
    - description: ID of the Tenant in which the incident resides
      name: tenant_id
    - description: ID of the incident to retrieve
      name: incident_id
      required: true
    description: get a specific incident from Respond
    name: respond-get-incident
    outputs:
    - contextPath: temp
      description: temp
      type: Unknown
  - arguments:
    - description: ID of the Tenant in which the incident resides
      name: tenant_id
    - description: ID of the incident to retrieve
      name: incident_id
      required: true
    - auto: PREDEFINED
      description: Outcome of the incident
      name: incident_feedback
      predefined:
      - ConfirmedIncident
      - NonActionable
      - Inconclusive
    - description: additional feedback information
      name: feedback_optional_text
    description: close an incident in Respond and provide feedback
    name: respond-close-incident
  - arguments:
    - description: respond incident id
      name: incident_id
      required: true
    - description: tenant id
      name: tenant_id
    - description: email
      name: username
      required: true
    description: add a user to a respond incident
    name: respond-assign-user
  - arguments:
    - description: incident id
      name: incident_id
      required: true
    - description: tenant id
      name: tenant_id
    - description: email
      name: username
      required: true
    description: remove a user from a Respond incident
    name: respond-remove-user
  dockerimage: demisto/gql:1.0.0.9687
  isfetch: true
  runonce: false
  script: >2


    # IMPORTS



    import json


    from gql import gql, Client

    from gql.transport.requests import RequestsHTTPTransport

    from datetime import datetime, timedelta


    # Disable insecure warnings

    requests.packages.urllib3.disable_warnings()


    ''' CONSTANTS/GLOBALS '''

    TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

    INTEGRATION_CONTEXT_BRAND = 'RespondSoftwareAnalyst'

    BASE_URL = demisto.params().get('base_url')

    USERNAME = demisto.params().get('username')

    PASSWORD = demisto.params().get('password')

    VERIFY_CERT = not demisto.params().get('insecure', False)



    def convert_epoch_to_milli(timestamp):
        if timestamp is None:
            return None
        if 9 < len(str(timestamp)) < 13:
            timestamp = int(timestamp) * 1000
        return int(timestamp)


    def convert_datetime_to_epoch(the_time=0):
        if the_time is None:
            return None
        try:
            if isinstance(the_time, datetime):
                return int(the_time.strftime('%s'))
        except Exception as err:
            demisto.error(err)
            return 0


    def convert_datetime_to_epoch_millis(the_time=0):
        return convert_epoch_to_milli(convert_datetime_to_epoch(the_time=the_time))


    # helper function gets incident ids from Respond into array format

    def extract_id(incident_id_map):
        return int(incident_id_map.get('id'))


    class RestClient(BaseClient):
        def get_tenant_mappings(self):
            # need to send one request to big-monolith service to get the external
    tenant id
            return self._http_request(
                method='GET',
                url_suffix='/session/tenantIdMapping',
                retries=3
            )

        def get_current_user(self):
            return self._http_request(
                method='GET',
                url_suffix='/session/activeUser',
                retries=3
            )

        def get_all_users(self):
            return self._http_request(
                method='GET',
                url_suffix='/api/v0/users',
                retries=3
            )


    class GraphQLClient(object):
        def __init__(self, tenant_id=None, verify=VERIFY_CERT, auth=(USERNAME, PASSWORD),
    fetch_schema_from_transport=True):
            sample_transport = RequestsHTTPTransport(
                url=BASE_URL + '/graphql?tenantId=' + tenant_id,
                use_json=True,
                auth=auth,
                verify=verify,
                retries=3
            )
            self.client = Client(
                transport=sample_transport,
                fetch_schema_from_transport=fetch_schema_from_transport,
            )

        def update_tenant_id(self, tenant_id):
            self.client.transport.url = BASE_URL + '/graphql?tenantId=' + tenant_id

        def execute_query(self, query, variable_values=None):
            gql_query = gql(query)
            response = self.client.execute(gql_query, variable_values=variable_values)
            return response

        def construct_and_send_get_incident_ids_query(self, from_time_str):
            if from_time_str == '':
                return self.execute_query('''
                query {
                    incidents(
                      statusFilters: [
                        { incidentStatus: Open },
                        { incidentStatus: Closed },
                      ]
                    ){ id }
                }
                ''')
            else:
                return self.execute_query('''
                    query {
                        incidents(
                            createdAfter:"''' + from_time_str + '''"
                        ){ id }
                    }
                ''')

        def construct_and_send_full_incidents_query(self, incident_ids):
            return self.execute_query('''
            query {
              fullIncidents(ids: ''' + str(incident_ids) + ''') {
                id
                dateCreated
                eventCount
                firstEventTime
                lastEventTime
                title
                attackStage
                assetClass
                probabilityBucket
                status
                priority
                internalSystems{
                    hostname
                }
                internalSystemsCount
                feedback {
                  newStatus
                  status
                  newSelectedOptions{
                    id
                    key
                    value
                  }
                  timeGiven
                  optionalText
                  userId
                  closedAt
                  closedBy
                }
                userIds
                tags {
                  label
                }
              }
            }
            ''')

        def construct_and_send_close_incident_mutation(self, feedback_status, feedback_selected_options,
                                                       feedback_optional_text, incident_id,
    user):
            if feedback_selected_options is None:
                feedback_selected_options = []

            query = '''
                mutation closeIncident(
                  $incidentId: ID!,
                  $user: User!,
                  $feedbackStatus: FeedbackStatus!,
                  $newFeedbackSelectedOptions: [FeedbackSelectionInput!],
                  $feedbackOptionalText: String,
                ){
                  closeIncident(
                    incidentId: $incidentId,
                    user: $user,
                    feedbackStatus: $feedbackStatus,
                    newFeedbackSelectedOptions: $newFeedbackSelectedOptions,
                    feedbackOptionalText: $feedbackOptionalText
                  )
                    {
                        id
                        status
                        feedback {
                          userId
                          newStatus
                          timeGiven
                          newSelectedOptions{
                            id
                            key
                            value
                          }
                          optionalText
                        }
                    }
                  }'''
            variables = {
                'incidentId': incident_id,
                'user': user,
                'feedbackStatus': feedback_status,
                'newFeedbackSelectedOptions': feedback_selected_options,
                'feedbackOptionalText': feedback_optional_text,
            }
            return self.execute_query(query, variables)

        def construct_and_send_add_user_to_incident_mutation(self, user_id, incident_id):
            query = '''mutation addUserToIncident($id: ID!, $userId: String!) {
                          addUserToIncident(incidentId: $id, userId: $userId) {
                            id
                            userIds
                          }
                        }'''
            variables = {
                'id': incident_id,
                'userId': user_id
            }
            return self.execute_query(query, variables)

        def construct_and_send_remove_user_from_incident_mutation(self, user_id, incident_id):
            query = '''mutation removeUserFromIncident($id: ID!, $userId: String!)
    {
                          removeUserFromIncident(incidentId: $id, userId: $userId)
    {
                            id
                            userIds
                          }
                        }'''
            variables = {
                'id': incident_id,
                'userId': user_id
            }
            return self.execute_query(query, variables)


    def test_module(client):
        """
        Returning 'ok' indicates that the integration works like it is supposed to.
    Connection to the service is successful.

        Returns:
            'ok' if test passed, anything else will fail the test.
        """
        response = client.construct_and_send_get_incident_ids_query(
            convert_datetime_to_epoch_millis(datetime.now() - timedelta(hours=1)))
        id_list = list(map(extract_id, response.get('incidents')))
        client.construct_and_send_full_incidents_query(id_list).get('fullIncidents')
        return 'ok'


    def fetch_incidents_for_tenant(graphql_client, respond_tenant_id, external_tenant_id,
    from_time):
        graphql_client.update_tenant_id(respond_tenant_id)

        # first time fetch is handled in query
        try:
            response = graphql_client.construct_and_send_get_incident_ids_query(from_time)
            id_list = list(map(extract_id, response.get('incidents')))
            raw_incidents = graphql_client.construct_and_send_full_incidents_query(id_list).get('fullIncidents')
        except Exception as err:
            # log error but continue getting incidents for other tenants
            demisto.error('Exception thrown retrieving incidents for tenant ' + external_tenant_id
    + ': \n ' + str(err))
            return []
        return raw_incidents


    def format_raw_incident(raw_incident, external_tenant_id, respond_tenant_id):
        # convert graphql response to standardized JSON output for an incident
        # only format feedback if exists
        if raw_incident.get('feedback') is not None:
            standardized_feedback = {
                'timeUpdated': raw_incident.get('feedback').get('timeGiven'),
                'userId': raw_incident.get('feedback').get('userId'),
                'outcome': raw_incident.get('feedback').get('newStatus'),
                'comments': raw_incident.get('feedback').get('optionalText'),
            }
        else:
            standardized_feedback = {}

        standardized_incident = {
            'incidentId': raw_incident.get('id'),
            'timeGenerated': timestamp_to_datestring(raw_incident.get('dateCreated'),
    TIME_FORMAT + 'Z'),
            'eventCount': raw_incident.get('eventCount'),
            'firstEventTime': timestamp_to_datestring(raw_incident.get('firstEventTime'),
    TIME_FORMAT + 'Z'),
            'lastEventTime': timestamp_to_datestring(raw_incident.get('lastEventTime'),
    TIME_FORMAT + 'Z'),
            'URL': BASE_URL + '/secure/incidents/' + raw_incident.get(
                'id') + '?tenantId=' + respond_tenant_id,
            'closeURL': BASE_URL + '/secure/incidents/feedback/' + raw_incident.get(
                'id') + '?tenantId=' + respond_tenant_id,
            'title': raw_incident.get('title'),
            'status': raw_incident.get('status'),
            'severity': raw_incident.get('priority'),
            'probability': raw_incident.get('probabilityBucket'),
            'attackStage': raw_incident.get('attackStage'),
            'attackTactic': raw_incident.get('attackTactic'),
            'assetCriticality': raw_incident.get('assetClass'),
            'internalSystemsCount': raw_incident.get('internalSystemsCount'),
            'internalSystems': raw_incident.get('internalSystems'),
            'escalationReasons': raw_incident.get('tags'),  # todo only get the labels
    with a mapping
            'assignedUsers': raw_incident.get('userIds'),
            'feedback': standardized_feedback,
            'tenantIdRespond': respond_tenant_id,
            'tenantId': external_tenant_id
        }
        # add tenant ids and incident URLs to incidents (cannot get them with gql
    query)
        raw_incident['tenantId'] = external_tenant_id
        raw_incident['incidentURL'] = BASE_URL + '/secure/incidents/' + raw_incident[
            'id'] + '?tenantId=' + respond_tenant_id
        raw_incident['incidentCloseURL'] = BASE_URL + '/secure/incidents/feedback/'
    + raw_incident[
            'id'] + '?tenantId=' + respond_tenant_id

        occurred = standardized_incident.get('timeGenerated')
        new_incident = {
            'name': external_tenant_id + ': ' + raw_incident['id'],  # or maybe this
    should be title?
            'occurred': occurred,
            'rawJSON': json.dumps(standardized_incident)
        }
        return new_incident


    def get_respond_tenant_from_mapping_with_external(tenant_mappings, external_tenant_id):
        """
        finds the respond tenant id that matches the external tenant id provided,
    if exists and accessible
        :param tenant_mappings: dictionary where (k,v) -> (respond_tenant_id,external_tenant_id)
        :param external_tenant_id:
        :return:
        """
        for curr_respond_tid, curr_external_tid in tenant_mappings.items():
            if external_tenant_id == curr_external_tid:
                return curr_respond_tid
        demisto.error('no respond tenant matches external tenant: ' + external_tenant_id
    + 'or user does not have '
                                                                                           'permission
    to access tenant')
        raise Exception('no respond tenant matches external tenant: ' + external_tenant_id
    + 'or user does not have '
                                                                                             'permission
    to access tenant')


    def get_tenant_map_if_single_tenant(user_tenant_mappings):
        """
        returns respond tenant id and external tenant id if the user is single tenant,
    otherwise raises exception
        :param user_tenant_mappings: list of user mappings. expect length 1
        :return: respond_tenant_id, external_tenant_id
        """
        if len(user_tenant_mappings) > 1:
            demisto.error('multi-tenant users must specify a tenant id in params,
    but no tenant id was found')
            raise Exception('multi-tenant users must specify a tenant id in params,
    but no tenant id was found')
        if len(user_tenant_mappings) == 0:
            demisto.error('no tenants found for user')
            raise Exception('no tenants found for user')
        return list(user_tenant_mappings.items())[0]


    def get_user_id_from_email(email, users):
        """
        given an email address and a list of Respond users, find the user id of the
    user with the provided email,
        and raise an exception if no user is found
        :param email: valid email for a user
        :param users: list of Respond Users
        :return: user id (string) of the user with email provided
        """
        # find the user id that matches the email provided in user_to_add field
        for user in users:
            if user.get('email') == email:
                return user.get('userId')

        raise Exception('no user found with email ' + email)


    def remove_user_command(rest_client, args, gql_client=None):
        external_tenant_id = args.get('tenant_id')
        incident_id = int(args['incident_id'])
        user_to_remove = args['username']
        user_tenant_mappings = rest_client.get_tenant_mappings()

        if external_tenant_id is None:
            respond_tenant_id, external_tenant_id = get_tenant_map_if_single_tenant(user_tenant_mappings)
        else:
            respond_tenant_id = get_respond_tenant_from_mapping_with_external(user_tenant_mappings,
    external_tenant_id)

        if gql_client is None:
            gql_client = GraphQLClient(tenant_id=respond_tenant_id)

        try:
            users = rest_client.get_all_users()
        except Exception as err:
            demisto.error('error adding user to incident: ' + str(err))
            raise Exception('error adding user to incident: ' + str(err))

        valid_user = False
        for user in users:
            if user.get('email') == user_to_remove:
                valid_user = True
                break

        if valid_user is False:
            demisto.error('no user found with email ' + user_to_remove)
            raise Exception('no user found with email ' + user_to_remove)

        try:
            res = gql_client.construct_and_send_remove_user_from_incident_mutation(user_to_remove,
    incident_id).get(
                'removeUserFromIncident')
            return 'user with email: ' + user_to_remove + ' removed from incident
    with id ' + res[
                'id'] + ' on tenant ' + str(external_tenant_id)
        except Exception as err:
            demisto.error('error removing user from incident: ' + str(err))
            raise Exception('error removing user from incident: ' + str(err))


    def assign_user_command(rest_client, args, gql_client=None):
        incident_id = int(args['incident_id'])
        user_to_add = args['username']
        external_tenant_id = args.get('tenant_id')
        user_tenant_mappings = rest_client.get_tenant_mappings()

        if external_tenant_id is None:
            respond_tenant_id, external_tenant_id = get_tenant_map_if_single_tenant(user_tenant_mappings)
        else:
            respond_tenant_id = get_respond_tenant_from_mapping_with_external(user_tenant_mappings,
    external_tenant_id)

        if gql_client is None:
            gql_client = GraphQLClient(tenant_id=respond_tenant_id)

        try:
            users = rest_client.get_all_users()
        except Exception as err:
            demisto.error('error adding user to incident: ' + str(err))
            raise Exception('error adding user to incident: ' + str(err))

        valid_user = False
        for user in users:
            if user.get('email') == user_to_add:
                valid_user = True
                break

        if valid_user is False:
            demisto.error('no user found with email ' + user_to_add)
            raise Exception('no user found with email ' + user_to_add)

        try:
            res = gql_client.construct_and_send_add_user_to_incident_mutation(user_to_add,
    incident_id).get(
                'addUserToIncident')
            return 'user with email: ' + user_to_add + ' added to incident with id
    ' + res['id'] + ' on tenant ' + str(
                external_tenant_id)
        except Exception as err:
            demisto.error('error adding user to incident: ' + str(err))
            raise Exception('error adding user to incident: ' + str(err))


    def close_incident_command(rest_client, args, gql_client=None):
        """
        :param rest_client: REST client
        :param args: parameters include: user_to_add:email, user_to_remove:email,
        feedback_status:string, feedback_selected_options:[{id, key, value}], feedback_optional_text:string
        :param gql_client: GraphQL Client
        :return: ??
        """
        respond_user = rest_client.get_current_user()
        user_tenant_mappings = rest_client.get_tenant_mappings()
        incident_id = int(args['incident_id'])
        external_tenant_id = args.get('tenant_id')

        if external_tenant_id is None:
            respond_tenant_id, external_tenant_id = get_tenant_map_if_single_tenant(user_tenant_mappings)
        else:
            respond_tenant_id = get_respond_tenant_from_mapping_with_external(user_tenant_mappings,
    external_tenant_id)

        if gql_client is None:
            gql_client = GraphQLClient(tenant_id=respond_tenant_id)

        feedback_status = args['incident_feedback']
        feedback_selected_options = args.get('feedback_selected_options')
        feedback_optional_text = args.get('incident_comments')
        try:
            incident = gql_client.construct_and_send_full_incidents_query([incident_id]).get('fullIncidents')[0]
            if feedback_status is None:
                if incident['status'] == 'Open':
                    demisto.error('cannot close an incident without providing feedback
    status')
                    raise Exception('cannot close an incident without providing feedback
    status')
                feedback_status = incident.get('feedback').get('newStatus')
            if incident.get('feedback') is not None:
                if feedback_selected_options is None:
                    feedback_selected_options = incident.get('feedback').get('newSelectedOptions')
                if feedback_optional_text is None:
                    feedback_optional_text = incident.get('feedback').get('optionalText')

            # get user info with rest client and construct user object
            respond_graphql_formatted_user = {
                'userId': respond_user['email'],
                'firstname': respond_user['firstname'],
                'lastname': respond_user['lastname']
            }
            res = gql_client.construct_and_send_close_incident_mutation(feedback_status,
    feedback_selected_options,
                                                                        feedback_optional_text,
    incident_id,
                                                                        respond_graphql_formatted_user)
            return ('incident closed and/or feedback updated for incident with id
    ' + str(incident_id)
                    + ' on tenant ' + external_tenant_id + ':\n' + str(res.get('closeIncident')))
        except Exception as err:
            demisto.error('error closing incident and/or updating feedback: ' + str(err))
            raise Exception('error closing incident and/or updating feedback: ' +
    str(err))


    def get_incident_command(rest_client, args, gql_client=None):
        external_tenant_id = args.get('tenant_id')
        user_tenant_mappings = rest_client.get_tenant_mappings()

        if external_tenant_id is None:
            respond_tenant_id, external_tenant_id = get_tenant_map_if_single_tenant(user_tenant_mappings)
        else:
            respond_tenant_id = get_respond_tenant_from_mapping_with_external(user_tenant_mappings,
    external_tenant_id)

        incident_id = int(args['incident_id'])

        if gql_client is None:
            gql_client = GraphQLClient(tenant_id=respond_tenant_id)

        raw_incident = gql_client.construct_and_send_full_incidents_query([incident_id])['fullIncidents'][0]
        return format_raw_incident(raw_incident, external_tenant_id, respond_tenant_id)


    def fetch_incidents(rest_client, last_run=dict(), graphql_client=None):
        """
        This function will execute each interval (default is 1 minute).

        Args:
            graphql_client (GraphQLClient): GraphQL client
            rest_client (Client): Demisto BaseClient
            last_run (dict): Information about the last successful execution of fetch
    incidents
            If last_run is None then fetch all open incidents

        Returns:
            next_run: This will be last_run in the next fetch-incidents
            incidents: Incidents that will be created in Demisto
        """
        if last_run is None:
            last_run = dict()

        # get tenant ids
        tenant_mappings = rest_client.get_tenant_mappings()

        if len(tenant_mappings) == 0:
            demisto.error('no tenants found for user')
            raise Exception('no tenants found for user')

        # create graphql client with first tenant and update tenant ids
        # we fetch the graphql schema when the client is setup and we need a valid
    url to point to
        # our tenant ids are part of the url. fortunately the graphql schema does
    not change across tenants
        if graphql_client is None:
            graphql_client = GraphQLClient(tenant_id=list(tenant_mappings.keys())[0])

        incidents = []
        next_run = last_run

        # get incidents for each tenant
        for respond_tenant_id, external_tenant_id in tenant_mappings.items():
            # Get the last fetch time for tenant, if exists, which will be used as
    the 'search from here onward' time
            if last_run.get(external_tenant_id):
                latest_time = last_run.get(external_tenant_id).get('time')
                # latest_time+1 (ms) to prevent duplicates
                from_time = datetime.utcfromtimestamp((int(latest_time) + 1) / 1000).strftime('%Y-%m-%d
    %H:%M:%S.%f')
            else:
                latest_time = None
                from_time = ''
            # convert to utc datetime for incidents filter
            raw_incidents = fetch_incidents_for_tenant(graphql_client, respond_tenant_id,
    external_tenant_id, from_time)

            # create to array of XSOAR incidents sort incidents by dateCreated. If
    an error occurs midway through we will
            # recollect after last successful incident todo but what if an incident
    is just bad? how can we know to skip
            #  it? I could store a list of ids that failed last time and rerun them
    once, if they fail then dont try
            #  again or something
            raw_incidents.sort(key=lambda x: x.get('dateCreated'))
            for raw_incident in raw_incidents:
                try:
                    incidents.append(format_raw_incident(raw_incident, external_tenant_id,
    respond_tenant_id))
                    if latest_time is None or raw_incident['dateCreated'] > latest_time:
                        latest_time = raw_incident['dateCreated']
                except Exception as err:
                    # todo should we break or continue - do we want to try and get
    this incident again or not
                    demisto.error('Exception thrown collecting specific incident for
    tenant: ' + external_tenant_id + str(
                        err) + '\n incident: ' + str(raw_incident))
                    break
            # store
            if external_tenant_id in next_run:
                next_run[external_tenant_id]['time'] = latest_time
            else:
                next_run[external_tenant_id] = {'time': latest_time}

        return next_run, incidents


    def main():
        """
        Executes an integration command
        """
        LOG('Command being called is ' + demisto.command())

        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        # big_monolith_base_url = demisto.params().get('big_monolith_base_url')
        rest_client = RestClient(
            base_url=BASE_URL,
            verify=VERIFY_CERT,
            auth=(USERNAME, PASSWORD),
            proxy=True
        )

        try:
            if demisto.command() == 'test-module':
                # todo
                demisto.results('ok')

            elif demisto.command() == 'fetch-incidents':
                # get all tenant ids
                next_run, incidents = fetch_incidents(rest_client, demisto.getLastRun())
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif demisto.command() == 'respond-close-incident':
                return_outputs(close_incident_command(rest_client, demisto.args()))

            elif demisto.command() == 'respond-assign-user':
                return_outputs(assign_user_command(rest_client, demisto.args()))

            elif demisto.command() == 'respond-remove-user':
                return_outputs(remove_user_command(rest_client, demisto.args()))

            elif demisto.command() == 'respond-get-incident':
                return_outputs(get_incident_command(rest_client, demisto.args()))

        except Exception as err:
            if demisto.command() == 'fetch-incidents':
                LOG(str(err))
                raise
            demisto.error("Uncaught exception: " + str(err))
            return_error(str(err))


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
image: data:image/png;base64,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
detaileddescription: >
  ### Developer Contributed Integration

  #### Integration Author: Respond Software

  Support and maintenance for this integration are provided by the author. Please
  use the following contact details:

  - **Email**: [danno@respond-software.com](mailto:danno@respond-software.com)

  ***

  ## Hello World

  - This text is markdown

  - Here you should explain how to configure the instance in Demisto
fromversion: 5.0.0
tests:
- No tests (auto formatted)
