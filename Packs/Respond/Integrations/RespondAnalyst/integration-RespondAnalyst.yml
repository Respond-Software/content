category: Analytics & SIEM
commonfields:
  id: Respond_Analyst
  version: -1
configuration:
- defaultvalue: None
  display: Incident Mirroring Direction
  hidden: false
  name: mirror_direction
  options:
  - None
  - Incoming
  - Outgoing
  - Both
  required: false
  type: 15
- display: base url
  name: base_url
  required: true
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Password
  name: password
  required: true
  type: 4
- display: Username
  name: username
  required: true
  type: 0
description: Respond Software Integration - fetches incidents with mirroring api enabled
display: Respond Analyst (Partner Contribution)
name: Respond_Analyst
script:
  commands:
  - arguments:
    - default: false
      description: ID of the Tenant in which the incident resides
      isArray: false
      name: respond_tenant_id
      required: false
      secret: false
    - default: false
      description: ID of the incident to retrieve
      isArray: false
      name: incident_id
      required: true
      secret: false
    deprecated: false
    description: get a specific incident from Respond
    execution: false
    name: respond-get-incident
    outputs:
    - contextPath: temp
      description: temp
      type: Unknown
  - arguments:
    - default: false
      description: ID of the Tenant in which the incident resides
      isArray: false
      name: respond_tenant_id
      required: false
      secret: false
    - default: false
      description: ID of the incident to retrieve
      isArray: false
      name: incident_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: Outcome of the incident
      isArray: false
      name: incident_feedback
      predefined:
      - ConfirmedIncident
      - NonActionable
      - Inconclusive
      required: false
      secret: false
    - default: false
      description: additional feedback information
      isArray: false
      name: feedback_optional_text
      required: false
      secret: false
    deprecated: false
    description: close an incident in Respond and provide feedback
    execution: false
    name: respond-close-incident
  - arguments:
    - default: false
      description: respond incident id
      isArray: false
      name: incident_id
      required: true
      secret: false
    - default: false
      description: tenant id
      isArray: false
      name: respond_tenant_id
      required: false
      secret: false
    - default: false
      description: email
      isArray: false
      name: username
      required: true
      secret: false
    deprecated: false
    description: add a user to a respond incident
    execution: false
    name: respond-assign-user
  - arguments:
    - default: false
      description: incident id
      isArray: false
      name: incident_id
      required: true
      secret: false
    - default: false
      description: tenant id
      isArray: false
      name: respond_tenant_id
      required: false
      secret: false
    - default: false
      description: email
      isArray: false
      name: username
      required: true
      secret: false
    deprecated: false
    description: remove a user from a Respond incident
    execution: false
    name: respond-remove-user
  - arguments:
    - default: false
      isArray: false
      name: incident_id
      required: true
      secret: false
    - default: false
      isArray: false
      name: respond_tenant_id
      required: true
      secret: false
    deprecated: false
    description: Get escalation data associated with incident
    execution: false
    name: respond-get-escalations
  dockerimage: demisto/python3:3.8.6.12176
  feed: false
  isfetch: true
  ismappable: true
  isremotesyncin: true
  isremotesyncout: true
  longRunning: false
  longRunningPort: false
  runonce: false
  script: >2



    import json

    from datetime import datetime, timedelta

    import dateparser


    # Disable insecure warnings

    requests.packages.urllib3.disable_warnings()


    ''' CONSTANTS/GLOBALS '''

    TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

    INTEGRATION_CONTEXT_BRAND = 'RespondSoftwareAnalyst'

    BASE_URL = demisto.params().get('base_url')

    USERNAME = demisto.params().get('username')

    PASSWORD = demisto.params().get('password')

    VERIFY_CERT = not demisto.params().get('insecure', False)


    MIRROR_DIRECTION = {
        'None': None,
        'Incoming': 'In',
        'Outgoing': 'Out',
        'Both': 'Both'
    }


    RESPOND_FEEDBACK_STATUS = {
        'ConfirmedIncident': 'Confirmed Incident',
        'NonActionable': 'Non-Actionable',
        'Inconclusive': 'Inconclusive'
    }


    RESPOND_INCIDENT_FIELDS = {
        "feedback comments": {
            "description": "the user assigned outcome of a closed incident",
            "xsoar_field_name": "feedbackcomments"
        },
        "title": {
            "description": "incident title",
            "xsoar_field_name": "Title"
        },
        "feedback outcome": {
            "description": "the outcome of the incident close",
            "xsoar_field_name": "feedbackoutcome"
        }
    }


    RESPOND_INCIDENT_TYPE_NAME = 'Respond Software Incident'


    def convert_epoch_to_milli(timestamp):
        if timestamp is None:
            return None
        if 9 < len(str(timestamp)) < 13:
            timestamp = int(timestamp) * 1000
        return int(timestamp)


    def convert_datetime_to_epoch(the_time=0):
        if the_time is None:
            return None
        try:
            if isinstance(the_time, datetime):
                return int(the_time.strftime('%s'))
        except Exception as err:
            demisto.error(err)
            return 0


    def convert_datetime_to_epoch_millis(the_time=0):
        return convert_epoch_to_milli(convert_datetime_to_epoch(the_time=the_time))


    def arg_to_timestamp(arg, arg_name: str, required: bool = False):
        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None

        if isinstance(arg, str) and arg.isdigit():
            # timestamp that str - we just convert it to int
            return int(arg)
        if isinstance(arg, str):
            # if the arg is string of date format 2019-10-23T00:00:00 or "3 days", etc
            date = dateparser.parse(arg, settings={'TIMEZONE': 'UTC'})
            if date is None:
                # if d is None it means dateparser failed to parse it
                raise ValueError(f'Invalid date: {arg_name}')

            return int(date.timestamp() * 1000)
        if isinstance(arg, (int, float)):
            return arg


    # helper function gets incident ids from Respond into array format

    def extract_id(incident_id_map):
        return int(incident_id_map.get('id'))


    class RestClient(BaseClient):
        def get_tenant_mappings(self):
            # need to send one request to big-monolith service to get the external tenant id
            tenant_mappings = self._http_request(
                method='GET',
                url_suffix='/session/tenantIdMapping',
                retries=3
            )
            if len(tenant_mappings) == 0:
                demisto.error('no tenants found for user')
                raise Exception('no tenants found for user')
            return tenant_mappings

        def get_current_user(self):
            return self._http_request(
                method='GET',
                url_suffix='/session/activeUser',
                retries=3
            )

        def get_all_users(self):
            return self._http_request(
                method='GET',
                url_suffix='/api/v0/users',
                retries=3
            )

        # sadly the linting process will fail if the format below is not used. Hard to read
        def construct_and_send_full_incidents_query(self, tenant_id, incident_ids):
            query = {"query": "query { fullIncidents(ids: " + str(incident_ids) + ") { "
                                                                                  "id "
                                                                                  "dateCreated "
                                                                                  "eventCount "
                                                                                  "firstEventTime "
                                                                                  "lastEventTime "
                                                                                  "title "
                                                                                  "description "
                                                                                  "attackStage "
                                                                                  "assetClass "
                                                                                  "probabilityBucket "
                                                                                  "status "
                                                                                  "priority "
                                                                                  "internalSystems{ "
                                                                                  "hostname "
                                                                                  "ipAddress"
                                                                                  "} "
                                                                                  "internalSystemsCount "
                                                                                  "feedback { "
                                                                                  "newStatus "
                                                                                  "status "
                                                                                  "newSelectedOptions{ "
                                                                                  "id "
                                                                                  "key "
                                                                                  "value "
                                                                                  "} "
                                                                                  "timeGiven "
                                                                                  "optionalText "
                                                                                  "userId "
                                                                                  "closedAt "
                                                                                  "closedBy "
                                                                                  "} "
                                                                                  "userIds "
                                                                                  "tags { "
                                                                                  "label "
                                                                                  "} "
                                                                                  "} }"
                     }
            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + tenant_id,
                retries=3,
                json_data=query
            )
            return res.get('data').get('fullIncidents')

        def construct_and_send_get_incident_ids_query(self, tenant_id, from_time_str):
            if from_time_str == '':
                query = {"query": "query { incidents( statusFilters: [ { incidentStatus: Open } { "
                                  "incidentStatus: Closed } ] ){ id } }"}
            else:
                query = {"query": "query { incidents( createdAfter:\"" + from_time_str + "\" ){ id } }"}
            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + tenant_id,
                retries=3,
                json_data=query
            )
            return res.get('data').get('incidents')

        def construct_and_send_close_incident_mutation(self, tenant_id, feedback_status,
                                                       feedback_selected_options,
                                                       feedback_optional_text, incident_id, user):
            if feedback_selected_options is None:
                feedback_selected_options = []

            # sadly the linting process will fail if the format below is not used. Hard to read
            data = {"query": "mutation closeIncident( "
                             "$incidentId: ID! "
                             "$user: User! "
                             "$feedbackStatus: FeedbackStatus! "
                             "$newFeedbackSelectedOptions: [FeedbackSelectionInput!] "
                             "$feedbackOptionalText: String ){ "
                             "closeIncident( "
                             "incidentId: $incidentId "
                             "user: $user "
                             "feedbackStatus: $feedbackStatus "
                             "newFeedbackSelectedOptions: $newFeedbackSelectedOptions "
                             "feedbackOptionalText: $feedbackOptionalText "
                             ") { "
                             "id "
                             "status "
                             "feedback { "
                             "userId "
                             "newStatus "
                             "timeGiven "
                             "newSelectedOptions{ "
                             "id "
                             "key "
                             "value "
                             "} "
                             "optionalText "
                             "} "
                             "} "
                             "}",
                    "variables": {"incidentId": incident_id, "user": user,
                                  "feedbackStatus": feedback_status,
                                  "newFeedbackSelectedOptions": feedback_selected_options,
                                  "feedbackOptionalText": feedback_optional_text}
                    }
            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + tenant_id,
                retries=3,
                json_data=data
            )
            return res.get('data').get('closeIncident')

        def construct_and_send_add_user_to_incident_mutation(self, tenant_id, user_id, incident_id):
            data = {"query": "mutation addUserToIncident($id: ID! $userId: String!) { "
                             "addUserToIncident(incidentId: $id userId: $userId) { "
                             "id "
                             "userIds "
                             "} "
                             "}",
                    "variables": {"id": incident_id, "userId": user_id}
                    }

            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + tenant_id,
                retries=3,
                json_data=data
            )
            return res.get('data').get('addUserToIncident')

        def construct_and_send_remove_user_from_incident_mutation(self, tenant_id, user_id,
                                                                  incident_id):
            data = {"query": "mutation removeUserFromIncident($id: ID! $userId: String!) { "
                             "removeUserFromIncident(incidentId: $id userId: $userId) { "
                             "id "
                             "userIds "
                             "} "
                             "}",
                    "variables": {"id": incident_id, "userId": user_id}
                    }

            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + tenant_id,
                retries=3,
                json_data=data
            )
            return res.get('data').get('removeUserFromIncident')

        def construct_and_send_new_escalations_query(self, tenant_id, incident_id):
            data = {"query": "query {"
                             "newEscalations(consumer: \"XSOAR" + str(tenant_id) + str(
                incident_id) + "\") { "
                               "    timeGenerated "
                               "    sourceType "
                               "    incident { "
                               "      id "
                               "      priority "
                               "      probabilityBucket "
                               "    } "
                               "    ... on NIDSEvent { "
                               "      idx "
                               "      nidsAction: action { "
                               "        action "
                               "      } "
                               "      actionExt "
                               "      trafficFlow "

                               "      signature { "
                               "        vendor "
                               "        category "
                               "        idx "
                               "      } "
                               "      signatureImportance "
                               "      signatureName "
                               "      categoryExt "
                               "      deviceId "

                               "      protocol "

                               "      sourceHostname "
                               "      sourceIpAddress "
                               "      sourceZone "
                               "      sourceSystem { "
                               "        isInternal "
                               "        isCritical "
                               "      } "
                               "      sourceAssetClassification "
                               "      sourceSubClassifications "
                               "      sourceCriticality "
                               "      sourcePort { "
                               "        number "
                               "      } "
                               "      sourceSuspicion "

                               "      destinationHostname "
                               "      destinationIpAddress "
                               "      destinationZone "
                               "      destinationSystem { "
                               "        isInternal "
                               "        isCritical "
                               "      } "
                               "      destinationAssetClassification "
                               "      destinationSubClassifications "
                               "      destinationCriticality "
                               "      destinationPort { "
                               "        number "
                               "      } "
                               "      destinationSuspicion "
                               "    } "
                               "    ... on AVEvent {"
                               "      system {"
                               "        hostname"
                               "        ipAddress"
                               "        zone "
                               "      }"
                               "      account {"
                               "        domain"
                               "        name"
                               "      }"
                               "      hash {"
                               "        hash"
                               "      }"
                               "      malwareName {"
                               "        name"
                               "        type"
                               "        vendor"
                               "      }"
                               "      accountType "
                               "      isKnownBadHash "
                               "      deviceId"
                               "      scanTypeExt"
                               "      actionExt"
                               "      malwareSeverity"
                               "      malwareSeverityExt"
                               "      malwareTypeExt"
                               "      assetClassification"
                               "      assetSubClassifications"
                               "      assetCriticality"
                               "      systemRepeatOffender"
                               "      accountRepeatOffender"
                               "      malwareSpreading"
                               "      avFilepath: filepath"
                               "    }"

                               "    ... on WPEvent {"
                               "      wpAction: action { "
                               "        action "
                               "      } "
                               "      sourceSystem {"
                               "        hostname"
                               "        ipAddress"
                               "        zone "
                               "        isInternal "
                               "      }"
                               "      sourceAssetClassification "
                               "      sourceSubClassifications "
                               "      sourceCriticality "
                               "      destinationAddress {"
                               "        hostname"
                               "        ipAddress"
                               "        zone "
                               "        isInternal "
                               "      }"
                               "      destinationAssetClassification "
                               "      destinationSubClassifications "
                               "      destinationCriticality "
                               "      account {"
                               "        domain"
                               "        name"
                               "      }"
                               "      accountType "
                               "      categorizationsExternal "
                               "      protocol "
                               "      method  "
                               "      status  "
                               "      userAgent "
                               "      contentType "
                               "      fileType    "
                               "      deviceId "
                               "      deviceVendor "
                               "      fullUrl "
                               "      campaign "
                               "  } "
                               "    ... on EDREvent {"
                               "      system {"
                               "        hostname"
                               "        ipAddress"
                               "        zone "
                               "        isInternal "
                               "      }"
                               "      assetClassification"
                               "      assetSubClassifications"
                               "      assetCriticality"
                               "      account {"
                               "        domain"
                               "        name"
                               "      }"
                               "      accountType "
                               "      deviceId "
                               "      deviceVendor "
                               "      edrFilepath: filepath "
                               "      fileHash "
                               "      watchlistName "
                               "      processName "
                               "      isBinarySigned "
                               "      parentProcessName "
                               "      parentFileHash "
                               "      parentFilepath "
                               "      isParentBinarySigned "
                               "      binarySuspicion "
                               "      accountActivitySuspicion "
                               "      diskOperationSuspicion "
                               "      networkConnectionSuspicion "
                               "    } "
                               "}"
                               "}"}
            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + tenant_id,
                retries=3,
                json_data=data,
                timeout=60
            )
            return res.get('data').get('newEscalations')

        def construct_and_send_update_description_mutation(self, respond_tenant_id, incident_id, description):
            data = {
                "query": "mutation updateIncidentDescription($incidentId: ID!, $input: IncidentDescription!) { "
                         "updateIncidentDescription( "
                         "incidentId: $incidentId "
                         "input: $input "
                         ") { "
                         "id "
                         "description"
                         "} "
                         "}",
                "variables": {"incidentId": incident_id, "input": {"description": description}}
            }

            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + respond_tenant_id,
                retries=3,
                json_data=data
            )
            return res.get('data').get('updateIncidentDescription')

        def construct_and_send_update_title_mutation(self, respond_tenant_id, incident_id, title):
            data = {
                "query": "mutation updateIncidentTitle($incidentId: ID!, $input: IncidentTitle!) { "
                         "updateIncidentTitle( "
                         "incidentId: $incidentId "
                         "input: $input "
                         ") { "
                         "id "
                         "title"
                         "} "
                         "}",
                "variables": {"incidentId": incident_id, "input": {"title": title}}
            }

            res = self._http_request(
                method='POST',
                url_suffix='/graphql?tenantId=' + respond_tenant_id,
                retries=3,
                json_data=data
            )
            return res.get('data').get('updateIncidentTitle')


    def test_module(client):
        """
        Returning 'ok' indicates that the integration works like it is supposed to. Connection to the service is successful.

        Returns:
            'ok' if test passed, anything else will fail the test.
        """
        response = client.construct_and_send_get_incident_ids_query(
            convert_datetime_to_epoch_millis(datetime.now() - timedelta(hours=1)))
        id_list = list(map(extract_id, response))
        client.construct_and_send_full_incidents_query(id_list)
        return 'ok'


    def fetch_incidents_for_tenant(rest_client, respond_tenant_id, external_tenant_id, from_time):
        # first time fetch is handled in query
        try:
            response = rest_client.construct_and_send_get_incident_ids_query(respond_tenant_id,
                                                                             from_time)
            id_list = list(map(extract_id, response))
            raw_incidents = rest_client.construct_and_send_full_incidents_query(respond_tenant_id,
                                                                                id_list)
        except Exception as err:
            # log error but continue getting incidents for other tenants
            demisto.error(
                'Exception thrown retrieving incidents for tenant ' + external_tenant_id + ': \n ' + str(
                    err))
            return []
        return raw_incidents


    def format_raw_incident(raw_incident, external_tenant_id, respond_tenant_id):
        # convert graphql response to standardized JSON output for an incident
        formatted_incident = {
            'incidentId': raw_incident.get('id'),
            'timeGenerated': timestamp_to_datestring(raw_incident.get('dateCreated'),
                                                     TIME_FORMAT + 'Z'),
            'eventCount': raw_incident.get('eventCount'),
            'firstEventTime': timestamp_to_datestring(raw_incident.get('firstEventTime'),
                                                      TIME_FORMAT + 'Z'),
            'lastEventTime': timestamp_to_datestring(raw_incident.get('lastEventTime'),
                                                     TIME_FORMAT + 'Z'),
            'URL': BASE_URL + '/secure/incidents/' + raw_incident.get(
                'id') + '?tenantId=' + respond_tenant_id,
            'closeURL': BASE_URL + '/secure/incidents/feedback/' + raw_incident.get(
                'id') + '?tenantId=' + respond_tenant_id,
            'title': raw_incident.get('title'),
            'description': raw_incident.get('description'),
            'status': raw_incident.get('status'),
            'severity': raw_incident.get('priority'),
            'probability': raw_incident.get('probabilityBucket'),
            'attackStage': raw_incident.get('attackStage'),
            'attackTactic': raw_incident.get('attackTactic'),
            'assetCriticality': raw_incident.get('assetClass'),
            'internalSystemsCount': raw_incident.get('internalSystemsCount'),
            'internalSystems': raw_incident.get('internalSystems'),
            'escalationReasons': raw_incident.get('tags'),
            'assignedUsers': raw_incident.get('userIds'),
            'tenantIdRespond': respond_tenant_id,
            'tenantId': external_tenant_id,
            'respondRemoteId': f'{external_tenant_id}:{raw_incident.get("id")}',
            'dbotMirrorDirection': MIRROR_DIRECTION.get(
                demisto.params().get('mirror_direction', 'None'), None),
            'dbotMirrorInstance': demisto.integrationInstance()
        }
        if len(raw_incident.get('userIds')) > 0:
            formatted_incident['owner'] = demisto.findUser(email=raw_incident.get('userIds')[0]).get(
                'username')

        if raw_incident.get('feedback') is not None:
            formatted_incident['feedback'] = {
                'timeUpdated': raw_incident.get('feedback').get('timeGiven'),
                'userId': raw_incident.get('feedback').get('userId'),
                'outcome': RESPOND_FEEDBACK_STATUS.get(raw_incident.get('feedback').get('newStatus')),
                'comments': raw_incident.get('feedback').get('optionalText')
            }
        return formatted_incident


    def get_internal_tenant_from_mapping_with_external(tenant_mappings, external_tenant_id):
        """
        finds the respond tenant id that matches the external tenant id provided, if exists and accessible
        :param tenant_mappings: dictionary where (k,v) -> (respond_tenant_id,external_tenant_id)
        :param external_tenant_id:
        :return:
        """
        for curr_internal_tid, curr_external_tid in tenant_mappings.items():
            if external_tenant_id == curr_external_tid:
                return curr_internal_tid
        demisto.error(
            'no respond tenant matches external tenant: ' + external_tenant_id + 'or user does not have '
                                                                                 'permission to access tenant')
        raise Exception(
            'no respond tenant matches external tenant: ' + external_tenant_id + 'or user does not have '
                                                                                 'permission to access tenant')


    def get_tenant_map_if_single_tenant(user_tenant_mappings):
        """
        returns respond tenant id and external tenant id if the user is single tenant, otherwise raises exception
        :param user_tenant_mappings: list of user mappings. expect length 1
        :return: respond_tenant_id, external_tenant_id
        """
        if len(user_tenant_mappings) > 1:
            demisto.error(
                'multi-tenant users must specify a tenant id in params, but no tenant id was found')
            raise Exception(
                'multi-tenant users must specify a tenant id in params, but no tenant id was found')
        if len(user_tenant_mappings) == 0:
            demisto.error('no tenants found for user')
            raise Exception('no tenants found for user')
        return list(user_tenant_mappings.items())[0]


    def get_user_id_from_email(email, users):
        """
        given an email address and a list of Respond users, find the user id of the user with the provided email,
        and raise an exception if no user is found
        :param email: valid email for a user
        :param users: list of Respond Users
        :return: user id (string) of the user with email provided
        """
        # find the user id that matches the email provided in user_to_add field
        for user in users:
            if user.get('email') == email:
                return user.get('userId')

        raise Exception('no user found with email ' + email)


    def get_formatted_incident(rest_client, args):
        external_tenant_id = args.get('respond_tenant_id')
        user_tenant_mappings = rest_client.get_tenant_mappings()

        if external_tenant_id is None:
            internal_tenant_id, external_tenant_id = get_tenant_map_if_single_tenant(
                user_tenant_mappings)
        else:
            internal_tenant_id = get_internal_tenant_from_mapping_with_external(user_tenant_mappings,
                                                                                external_tenant_id)

        incident_id = int(args['incident_id'])

        raw_incident = \
            rest_client.construct_and_send_full_incidents_query(internal_tenant_id, [incident_id])[0]

        return format_raw_incident(raw_incident, external_tenant_id, internal_tenant_id)


    def get_tenant_ids(rest_client, args):
        external_tenant_id = args.get('respond_tenant_id')
        user_tenant_mappings = rest_client.get_tenant_mappings()

        if external_tenant_id is None:
            internal_tenant_id, external_tenant_id = get_tenant_map_if_single_tenant(
                user_tenant_mappings)
        else:
            internal_tenant_id = get_internal_tenant_from_mapping_with_external(user_tenant_mappings,
                                                                               external_tenant_id)
        return internal_tenant_id, external_tenant_id


    def validate_user(rest_client, args):
        user_to_remove = args['username']

        try:
            users = rest_client.get_all_users()
        except Exception as err:
            demisto.error('error adding user to incident: ' + str(err))
            raise Exception('error adding user to incident: ' + str(err))

        valid_user = False
        for user in users:
            if user.get('email') == user_to_remove:
                valid_user = True
                break

        if valid_user is False:
            demisto.error('no user found with email ' + user_to_remove)
            raise Exception('no user found with email ' + user_to_remove)

        return user_to_remove


    def remove_user_command(rest_client, args):
        incident_id = int(args['incident_id'])
        respond_tenant_id, external_tenant_id = get_tenant_ids(rest_client, args)
        user_to_remove = validate_user(rest_client, args)

        try:
            res = rest_client.construct_and_send_remove_user_from_incident_mutation(respond_tenant_id,
                                                                                    user_to_remove,
                                                                                    incident_id)
            return 'user with email: ' + user_to_remove + ' removed from incident with id ' + res[
                'id'] + ' on tenant ' + str(external_tenant_id)
        except Exception as err:
            demisto.error('error removing user from incident: ' + str(err))
            raise Exception('error removing user from incident: ' + str(err))


    def assign_user_command(rest_client, args):
        incident_id = int(args['incident_id'])
        respond_tenant_id, external_tenant_id = get_tenant_ids(rest_client, args)
        user_to_add = validate_user(rest_client, args)

        try:
            res = rest_client.construct_and_send_add_user_to_incident_mutation(respond_tenant_id,
                                                                               user_to_add,
                                                                               incident_id)
            return 'user with email: ' + user_to_add + ' added to incident with id ' + res.get('id') + \
                   ' on tenant ' + str(external_tenant_id)
        except Exception as err:
            demisto.error('error adding user to incident: ' + str(err))
            raise Exception('error adding user to incident: ' + str(err))


    def close_incident_command(rest_client, args):
        """
        :param rest_client: REST client
        :param args: parameters include: user_to_add:email, user_to_remove:email,
        feedback_status:string, feedback_selected_options:[{id, key, value}], feedback_optional_text:string
        :return: ??
        """
        respond_user = rest_client.get_current_user()
        incident_id = int(args['incident_id'])
        respond_tenant_id, external_tenant_id = get_tenant_ids(rest_client, args)

        feedback_status = args['incident_feedback']
        feedback_selected_options = args.get('feedback_selected_options')
        feedback_optional_text = args.get('incident_comments')
        try:
            incident = \
                rest_client.construct_and_send_full_incidents_query(respond_tenant_id, [incident_id])[0]
            if feedback_status is None:
                if incident.get('status') == 'Open':
                    demisto.error('cannot close an incident without providing feedback status')
                    raise Exception('cannot close an incident without providing feedback status')
                feedback_status = incident.get('feedback').get('newStatus')
            if incident.get('feedback') is not None:
                if feedback_selected_options is None:
                    feedback_selected_options = incident.get('feedback').get('newSelectedOptions')
                if feedback_optional_text is None:
                    feedback_optional_text = incident.get('feedback').get('optionalText')

            # get user info with rest client and construct user object
            respond_graphql_formatted_user = {
                'userId': respond_user['email'],
                'firstname': respond_user['firstname'],
                'lastname': respond_user['lastname']
            }
            res = rest_client.construct_and_send_close_incident_mutation(respond_tenant_id,
                                                                         feedback_status,
                                                                         feedback_selected_options,
                                                                         feedback_optional_text,
                                                                         incident_id,
                                                                         respond_graphql_formatted_user)
            return ('incident closed and/or feedback updated for incident with id ' + str(incident_id)
                    + ' on tenant ' + external_tenant_id + ':\n' + str(res))
        except Exception as err:
            demisto.error('error closing incident and/or updating feedback: ' + str(err))
            raise Exception('error closing incident and/or updating feedback: ' + str(err))


    def get_incident_command(rest_client, args):
        formatted_incident = get_formatted_incident(rest_client, args)
        new_incident = {
            'name': args['respond_tenant_id'] + ': ' + formatted_incident['incidentId'],
            'occurred': formatted_incident.get('timeGenerated'),
            'rawJSON': json.dumps(formatted_incident)
        }
        return new_incident


    def get_escalations_command(rest_client, args):
        start = datetime.now().timestamp()
        fourMinutes = 240
        demisto.debug(
            f'getting escalations for incident {args["incident_id"]} on {args["respond_tenant_id"]} starting at {start}')
        try:
            entries = []
            user_tenant_mappings = rest_client.get_tenant_mappings()
            internal_tenant_id = get_internal_tenant_from_mapping_with_external(user_tenant_mappings,
                                                                                        args['respond_tenant_id'])
            more_data = True
            while more_data:
                if datetime.now().timestamp() - start > fourMinutes:
                    demisto.debug(
                        f'exiting safely for incident {args["incident_id"]} on {args["respond_tenant_id"]} starting at {start}')
                    entries.append({
                        'Type': EntryType.NOTE,
                        'Contents': 'Safely exited before timeout, but more data needs to be collected. Please re-run command.',
                        'ContentsFormat': EntryFormat.TEXT
                    })
                    break
                all_escalations = rest_client.construct_and_send_new_escalations_query(
                    internal_tenant_id, args['incident_id'])
                for escalation in all_escalations:
                    valid_entry = {
                        'Type': EntryType.NOTE,
                        'Contents': escalation,
                        'ContentsFormat': EntryFormat.JSON
                    }
                    entries.append(valid_entry)
                if len(all_escalations) == 0:
                    more_data = False
        except Exception as e:
            demisto.debug(
                f'Error while getting escalation data in Respond incoming mirror for incident {args["id"]} \n'
                f'Error message: {str(e)}')
            raise e
        if len(entries) == 0:
            entries.append({
                'Type': EntryType.NOTE,
                'Contents': 'No new escalations',
                'ContentsFormat': EntryFormat.TEXT
            })

        demisto.debug(
            f'returning escalations for incident {args["incident_id"]} on {args["respond_tenant_id"]}: {entries}')
        return entries


    def get_remote_data_command(rest_client, args):
        args['respond_tenant_id'] = args.get('id').split(':')[0]
        args['incident_id'] = args.get('id').split(':')[1]
        entries = []
        try:
            updated_incident = get_formatted_incident(rest_client, args)
            updated_incident['id'] = args.get('id')
            demisto.debug(f"Respond incident {args.get('id')}\n"
                          f"update time:   {arg_to_timestamp(args.get('last_update'), 'last_update')}")
        except Exception as e:
            demisto.debug(
                f'Error while getting incident data in Respond incoming mirror for incident {args["id"]} \n'
                f'Error message: {str(e)}')
            raise e

        # updated_incident['feedback'] = get_incident_feedback(updated_incident)
        demisto.debug(f'incident feedback: {updated_incident.get("feedback")}')

        if updated_incident['feedback'] is not None:
            demisto.debug(f"Closing Respond issue {updated_incident.get('id')}")
            closing_entry = {
                'Type': EntryType.NOTE,
                'Contents': {
                    'dbotIncidentClose': True,
                    'closeReason': updated_incident.get('feedback').get('outcome'),
                    'closeNotes': updated_incident.get('feedback').get('comments')
                },
                'ContentsFormat': EntryFormat.JSON
            }
            entries.append(closing_entry)
            demisto.debug(f'entries: {closing_entry} for incident {args["incident_id"]}')

        demisto.debug(f'update incident: {updated_incident} for incident {args["incident_id"]}')

        return [updated_incident] + entries


    def update_remote_system_command(rest_client, args):
        remote_args = UpdateRemoteSystemArgs(args)
        try:
            if remote_args.delta:
                # get incident id and tenant id from remote_system_id
                tenant_id = remote_args.remote_incident_id.split(':')[0]
                incident_id = remote_args.remote_incident_id.split(':')[1]
                user_tenant_mappings = rest_client.get_tenant_mappings()
                internal_tenant_id = get_internal_tenant_from_mapping_with_external(user_tenant_mappings, tenant_id)

                demisto.debug(f'Got the following delta keys {str(list(remote_args.delta.keys()))} to '
                              f' update Respond incident {remote_args.remote_incident_id}')

                if remote_args.delta.get('title'):
                    demisto.debug(
                        f'changed title for {remote_args.remote_incident_id}: {remote_args.delta["title"]}')
                    rest_client.construct_and_send_update_title_mutation(internal_tenant_id, incident_id,
                                                                               remote_args.delta[
                                                                                   'title'])

                if remote_args.delta.get('responddescription'):
                    demisto.debug(
                        f'changed description for {remote_args.remote_incident_id}: {remote_args.delta["responddescription"]}')
                    rest_client.construct_and_send_update_description_mutation(internal_tenant_id, incident_id,
                                                                           remote_args.delta[
                                                                               'responddescription'])

                if remote_args.delta.get('closeReason'):
                    #todo do we want to map xsoar close reasons to respond incident outcomes
                    # for now just set everything to inconclusive
                    feedback_args = {
                        'respond_tenant_id': tenant_id,
                        'incident_id': incident_id,
                        'incident_feedback': 'Inconclusive',
                        'incident_comments': remote_args.delta.get('closeNotes')
                    }
                    demisto.debug(
                        f'feedback args for {remote_args.remote_incident_id}: {feedback_args}')
                    close_incident_command(rest_client, feedback_args)
                if remote_args.delta.get('owner'):
                    #todo support unassign
                    demisto.debug(f'changed owner for {remote_args.remote_incident_id}: {remote_args.delta["owner"]}')
                    user_email = demisto.findUser(username=remote_args.delta['owner']).get('email')
                    assigned_user_args = {
                        'respond_tenant_id': tenant_id,
                        'incident_id': incident_id,
                        'username': user_email
                    }
                    demisto.debug(f'assigned user args {assigned_user_args}')
                    assign_user_command(rest_client, assigned_user_args)

        except Exception as e:
            demisto.debug(
                f"Error in Respond outgoing mirror for incident {remote_args.remote_incident_id} Error message: {str(e)}")

        return remote_args.remote_incident_id


    def get_mapping_fields_command():
        respond_incident_type_scheme = SchemeTypeMapping(type_name=RESPOND_INCIDENT_TYPE_NAME)
        for field in RESPOND_INCIDENT_FIELDS:
            respond_incident_type_scheme.add_field(name=field,
                                                   description=RESPOND_INCIDENT_FIELDS[field].get(
                                                       'description'))

        mapping_response = GetMappingFieldsResponse()
        mapping_response.add_scheme_type(respond_incident_type_scheme)
        return mapping_response


    def fetch_incidents(rest_client, last_run=dict()):
        """
        This function will execute each interval (default is 1 minute).

        Args:
            rest_client (Client): Demisto BaseClient
            last_run (dict): Information about the last successful execution of fetch incidents
            If last_run is None then fetch all open incidents

        Returns:
            next_run: This will be last_run in the next fetch-incidents
            incidents: Incidents that will be created in Demisto
        """
        if last_run is None:
            last_run = dict()

        # get tenant ids
        tenant_mappings = rest_client.get_tenant_mappings()

        incidents = []
        next_run = last_run

        # get incidents for each tenant
        for respond_tenant_id, external_tenant_id in tenant_mappings.items():
            # Get the last fetch time for tenant, if exists, which will be used as the 'search from here onward' time
            latest_time = None
            from_time = ''
            if last_run.get(external_tenant_id) is not None:
                latest_time = last_run.get(external_tenant_id).get('time')
                if latest_time is not None:
                    # latest_time+1 (ms) to prevent duplicates
                    from_time = datetime.utcfromtimestamp((int(latest_time) + 1) / 1000).strftime(
                        '%Y-%m-%d %H:%M:%S.%f')

            # convert to utc datetime for incidents filter
            raw_incidents = fetch_incidents_for_tenant(rest_client, respond_tenant_id,
                                                       external_tenant_id, from_time)

            raw_incidents.sort(key=lambda x: x.get('dateCreated'))
            for raw_incident in raw_incidents:
                try:
                    formatted_incident = format_raw_incident(raw_incident, external_tenant_id,
                                                             respond_tenant_id)
                    new_incident = {
                        'name': external_tenant_id + ': ' + raw_incident['id'],
                        'occurred': formatted_incident.get('timeGenerated'),
                        'rawJSON': json.dumps(formatted_incident)
                    }
                    incidents.append(new_incident)
                    if latest_time is None or raw_incident['dateCreated'] > latest_time:
                        latest_time = raw_incident['dateCreated']
                except Exception as err:
                    demisto.error(
                        'Exception thrown collecting specific incident for tenant: ' + external_tenant_id + str(
                            err) + '\n incident: ' + str(raw_incident))
                    break
            # store
            if external_tenant_id in next_run:
                next_run[external_tenant_id]['time'] = latest_time
            else:
                next_run[external_tenant_id] = {'time': latest_time}

        return next_run, incidents


    def main():
        """
        Executes an integration command
        """
        LOG('Command being called is ' + demisto.command())

        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """

        rest_client = RestClient(
            base_url=BASE_URL,
            verify=VERIFY_CERT,
            auth=(USERNAME, PASSWORD),
            proxy=True
        )

        try:
            if demisto.command() == 'test-module':
                # todo
                demisto.results('ok')

            elif demisto.command() == 'fetch-incidents':
                # get all tenant ids
                next_run, incidents = fetch_incidents(rest_client, demisto.getLastRun())
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif demisto.command() == 'respond-close-incident':
                return_outputs(close_incident_command(rest_client, demisto.args()))

            elif demisto.command() == 'respond-assign-user':
                return_outputs(assign_user_command(rest_client, demisto.args()))

            elif demisto.command() == 'respond-remove-user':
                return_outputs(remove_user_command(rest_client, demisto.args()))

            elif demisto.command() == 'respond-get-incident':
                return_outputs(get_incident_command(rest_client, demisto.args()))

            elif demisto.command() == 'update-remote-system':
                demisto.debug('in update-remote-system')
                return_results(update_remote_system_command(rest_client, demisto.args()))

            elif demisto.command() == 'get-mapping-fields':
                demisto.debug('get-mapping-fields called')
                return_results(get_mapping_fields_command())

            elif demisto.command() == 'get-remote-data':
                return_results(get_remote_data_command(rest_client, demisto.args()))

            elif demisto.command() == 'respond-get-escalations':
                return_results(get_escalations_command(rest_client, demisto.args()))

        except Exception as err:
            demisto.debug(f'Error caught at top level: {str(err)}')
            if demisto.command() == 'fetch-incidents':
                LOG(str(err))
                raise
            return_error(str(err))


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
tests:
- No tests (auto formatted)
defaultmapperin: Respond Analyst (mapper)
defaultclassifier: Respond Analyst (classifier)
fromversion: 5.0.0
image: data:image/png;base64,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
detaileddescription: >
  ### Partner Contributed Integration

  #### Integration Author: Respond Software

  Support and maintenance for this integration are provided by the author. Please use the following contact details:

  - **URL**: [https://github.com/dannomayernotabot](https://github.com/dannomayernotabot)

  ***

  ### Developer Contributed Integration

  #### Integration Author: Respond Software

  Support and maintenance for this integration are provided by the author. Please use the following contact details:

  - **Email**: [danno@respond-software.com](mailto:danno@respond-software.com)

  ***

  ## Hello World

  - This text is markdown

  - Here you should explain how to configure the instance in Demisto
